//Utility
sleep = native::sys.sleep

//Printing
print = native::sys.print
printErr = native::sys.printErr

println = $ arg="" print(arg + "\n")
printlnErr = $ arg="" printErr(arg + "\n")

//Field manipulation & reflection
paramCount = native::sys.paramCount
reqParamCount = native::sys.reqParamCount
defParamCount = native::sys.defParamCount
get = native::sys.get
set = native::sys.set
del = native::sys.del
fields = native::sys.fields
fieldData = native::sys.fieldData
has = $ obj,field,params=void {
    if params == void {
        return: get(obj, field) != void
    } else if params == null {
        val = get(obj, field)
        return: val != void && paramCount(val) != void
    } else {
        val = get(obj, field)
        return: val != void && reqParamCount(val) == params
    }
}
hasFunction = $ (obj,field,params=null) return: has(obj, field, params)
absorbFields = $ src,dst {
    data = fieldData(src)
    for data {
        if !it.isNoimport && !it.isPrivate {
            set(dst, it.name, it.exactValue)
        }
    }
}
eval = native::sys.eval
evalIn = native::sys.evalIn
identity = native::sys.identity

//Import
import = native::sys.import
importFrom = $ mod,field return: get(import(mod), field)
importTo = $ mod,trgt {absorbFields(import(mod), trgt)}
importSys = $ return: import("shnap.sys")
importSysTo = $ trgt {importTo("shnap.sys", trgt)}

//Types
javaClass = native::java.javaClass
javaArray = native::java.javaArray
javaCast = native::java.javaCast

num = native::type.num
dec = native::type.dec
int = native::type.int
str = native::type.str
bool = native::type.bool
array = native::type.array
char = native::type.char
java = native::type.java
ord = $ ch return: int32(num(ch))
newArray = native::type.newArray

int32 = native::type.int32
int64 = native::type.int64
float64 = native::type.float64 //Right now there's no float32, since it's introduction would created complex casting rules