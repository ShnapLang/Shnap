abs = $ obj {return: if(obj < 0) -obj else obj}

floor = $ x {
    xn = int(x)
    if x == xn || x > 0
        return: xn
    else
        return: xn - 1
}
ceil = $ x {
    flr = floor(x)
    if x == flr
        return: x
    else
        return: flr + 1
}

primeFactors = $ x {
    tests = sievePrimes(x**0.5 + 1)
    res = import("shnap.collections.array_list").arrayList()
    for tests
        if (x % it == 0) res.append(it)
    if (res.len() == 0) res.append(x)
    return: res
}

factors = $ x {
    res = import("shnap.collections.array_list").arrayList()
    for range(x,inclusive=true)
        if (x % it == 0) res.append(it)
    return: res
}

prime = $ x {
    if (x < 2) return: false
    if(x == 2 || x == 3) return: true
    if(x % 2 == 0 || x % 3 == 0) return: false
    rt = x**0.5
    i = 6
    while (i <= rt) {
        if ((x % (i - 1) == 0) || (x % (i + 1) == 0)) return: false
        i += 6
    }

    return: true
}

sievePrimes = $ limit {
    bools = newArray(limit-1)
    primes = import("shnap.collections.array_list").arrayList()

    for range(bools.len()) bools[it] = true

    for range(2, limit) {
        if bools[it-2] {
            j = it*2
            while (j <= limit) {
                bools[j-2] = false
                j += it
            }
        }
    }

    for range(bools.len())
        if (bools[it]) primes.append(it+2)

    return: primes
}

sum = $ val,vals...=void {
    if vals == void {
        res = 0
        for val
            res += num(it)
        return: res
    } else {
        res = 0
        res += num(val)
        for vals
            res += num(it)
        return: res
    }
}

min_max_identity = #{}
private min_max_identity

max = $ val,vals...=void {
    res = min_max_identity
    if vals == void {
        for val
            if res === min_max_identity || it > res
                res = it
    } else {
        res = val
        for vals
            if it > res
                res = it
    }
    return: res
}

min = $ val,vals...=void {
    res = min_max_identity
    if vals == void {
        for val
            if res === min_max_identity || it < res
                res = it
    } else {
        res = val
        for vals
            if it < res
                res = it
    }
    return: res
}

complex = @ (real=0.0,imaginary=0.0) {
    real = dec(real)
    imaginary = dec(imaginary)

    add = $ clx,order=1 {
        return: complex(real + clx.real, imaginary + clx.imaginary)
    }

    subtract = $ clx,order=1 {
        if order == 1
            return: complex(real - clx.real, imaginary - clx.imaginary)
        else
            return: complex(clx.real - real, imaginary - clx.imaginary)
    }

    multiply = $ clx,order=1 {
        return: complex(real * clx.real - imaginary * clx.imaginary, clx.real * imaginary + clx.imaginary * real)
    }

    divide = $ clx,order=1 {
        if order == 1 {
            denom = clx.real**2 + clx.imaginary**2
            if denom == 0
                return: void
            return: complex((real * clx.real + imaginary * clx.imaginary) / denom, (clx.real * imaginary - real * clx.imaginary) / denom)
        } else {
            denom = real**2 + imaginary**2
            if denom == 0
                return: void
            return: complex((real * clx.real + imaginary * clx.imaginary) / denom, (real * clx.imaginary - clx.real * imaginary) / denom)
        }
    }

    asString = $ {
        return: str(real) + " + " + str(imaginary) + "i"
    }

    round = $ n {
        return: complex(real.round(n), imaginary.round(n))
    }

}